#lang sicp

(define (no-more? coin-values)
  (null? coin-values))

(define (except-first-denomination coin-values)
  (cdr coin-values))

(define (first-denomination coin-values)
  (car coin-values))

(define (cc amount coin-values)
  (cond ((= amount 0) 1)
        ((or (< amount 0) (no-more? coin-values)) 0)
        (else (+
               (cc
                amount
                (except-first-denomination coin-values))
               (cc
                (- amount (first-denomination coin-values))
                coin-values)))))

(define us-coins (list 50 25 10 5 1))

(define uk-coins (list 100 50 20 10 5 2 1 0.5))

; The order of the list coin-values does not affect the answer produced by cc. Every possible change 
; is represented by a path on the tree generated by cc recursive process. This tree is binary: 
; the left branch represents the number of possible changes with the reduced coin pool, and the right 
; branch represents the number of possible changes with a particual coin picked. All paths that 
; represent the possible changes end on the right branch as its where the base condition that returns 
; "1" is. By shuffling the coin-values list, we reorder the elements on the path only, not generate 
; different paths, e.g. for amount = 100 and coin-values = (50 25), 50, 25, 25 and 25, 50, 25 are the 
; changes and paths, just reordered.